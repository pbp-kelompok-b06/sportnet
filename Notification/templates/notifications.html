{% extends 'base.html' %}
{% load static %}

{% block content %}
{% include 'navbar.html' %}
<div class="h-16 md:h-20"></div>

<header class="text-center mb-6 bg-[url('{% static "images/banner.jpg" %}')] bg-no-repeat bg-center bg-cover py-8 px-4">
  <h1 class="text-2xl md:text-3xl font-bold text-white">Notifications</h1>
  <p class="text-sm text-white/90 mt-2">Latest activity and alerts for your account</p>
</header>

<main class="container mx-auto px-4 pb-12">
  <div class="max-w-4xl mx-auto">
    <div class="flex items-center justify-between mb-4">
      <div class="flex items-center gap-3">
        <h2 class="text-xl font-semibold text-gray-800">All notifications</h2>
        <span id="unread-count" class="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-700 hidden">0</span>
      </div>
      <div class="flex items-center gap-2">
        <button id="mark-all-read" class="px-3 py-1 rounded-full bg-gray-100 text-gray-700 hover:bg-gray-200 transition">Mark all as read</button>
        <a href="{% url 'Homepage:notifications_settings' %}" class="text-sm text-gray-500 hover:underline">Settings</a>
      </div>
    </div>

    <div id="notifications-list" class="space-y-3">
      <!-- notification items injected here -->
      <div id="loading" class="text-center text-gray-500 py-12">Loading notifications…</div>
    </div>

    <div id="no-notifs" class="hidden text-center text-gray-500 py-12">
      No notifications.
    </div>
  </div>
</main>
{% endblock content %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function () {
  const listEl = document.getElementById('notifications-list');
  const loadingEl = document.getElementById('loading');
  const noNotifsEl = document.getElementById('no-notifs');
  const unreadBadge = document.getElementById('unread-count');
  const markAllBtn = document.getElementById('mark-all-read');

  const jsonUrl = "{% url 'Homepage:get_notifications_json' %}"; // adjust url name if different

  function notifHtml(n) {
    // n: { id, title, body, created_at, read (bool), icon_url? }
    const isRead = !!n.read;
    const rootClasses = isRead ? 'bg-white' : 'bg-gradient-to-r from-white to-[#FFF7F5]';
    const textColor = isRead ? 'text-gray-700' : 'text-gray-900 font-semibold';
    const time = n.created_at ? new Date(n.created_at).toLocaleString() : '';

    return `
      <article data-id="${n.id}" class="p-4 rounded-xl shadow-sm flex items-start gap-4 ${rootClasses} transition-colors duration-200">
        <div class="flex-shrink-0">
          <button class="notif-toggle w-10 h-10 rounded-full bg-gray-100 flex items-center justify-center text-gray-500 transition transform" aria-pressed="${isRead}">
            <!-- SVG-icon changes only (stroke/fill follow currentColor) -->
            <svg class="w-5 h-5 notif-icon stroke-current fill-current transition-colors duration-200" viewBox="0 0 24 24" fill="${isRead ? 'none' : 'currentColor'}" xmlns="http://www.w3.org/2000/svg" stroke="${isRead ? '#9CA3AF' : '#EF4444'}" stroke-width="1.5">
              <path d="M5 12h14M12 5v14" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>

        <div class="flex-1">
          <div class="flex items-start justify-between gap-4">
            <div>
              <div class="${textColor}">${escapeHtml(n.title || 'Notification')}</div>
              <p class="text-sm text-gray-500 mt-1">${escapeHtml(n.body || '')}</p>
            </div>
            <time class="text-xs text-gray-400 whitespace-nowrap">${escapeHtml(time)}</time>
          </div>
        </div>
      </article>
    `;
  }

  function escapeHtml(str) {
    if (!str) return '';
    return String(str)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function renderList(items) {
    if (!Array.isArray(items) || items.length === 0) {
      listEl.innerHTML = '';
      noNotifsEl.classList.remove('hidden');
      loadingEl?.remove();
      unreadBadge.classList.add('hidden');
      return;
    }

    noNotifsEl.classList.add('hidden');
    loadingEl?.remove();

    listEl.innerHTML = items.map(notifHtml).join('');

    // unread count
    const unreadCount = items.filter(i => !i.read).length;
    if (unreadCount > 0) {
      unreadBadge.textContent = unreadCount;
      unreadBadge.classList.remove('hidden');
    } else {
      unreadBadge.classList.add('hidden');
    }

    // Attach listeners: toggle read per item (change only SVG & aria)
    listEl.querySelectorAll('.notif-toggle').forEach(btn => {
      btn.addEventListener('click', async function (e) {
        e.preventDefault();
        const article = this.closest('article');
        if (!article) return;
        const id = article.getAttribute('data-id');
        const icon = this.querySelector('.notif-icon');
        const currentlyRead = this.getAttribute('aria-pressed') === 'true';

        // Toggle local UI (only icon/color and aria)
        this.setAttribute('aria-pressed', (!currentlyRead).toString());
        icon.style.transition = 'transform .12s ease';
        icon.classList.toggle('scale-105');

        // Update icon color/fill via inline attributes — prefer CSS classes, but change only svg attributes to be safe
        if (currentlyRead) {
          icon.setAttribute('stroke', '#EF4444');
          icon.setAttribute('fill', 'currentColor');
          article.classList.remove('bg-white');
          article.classList.add('bg-gradient-to-r','from-white','to-[#FFF7F5]');
        } else {
          icon.setAttribute('stroke', '#9CA3AF');
          icon.setAttribute('fill', 'none');
          article.classList.remove('bg-gradient-to-r','from-white','to-[#FFF7F5]');
          article.classList.add('bg-white');
        }

        // Optional: send toggle to backend (fire-and-forget)
        try {
          await fetch("{% url 'Homepage:toggle_notification_read' 0 %}".replace('/0/', `/${id}/`), {
            method: 'POST',
            headers: {
              'X-CSRFToken': getCsrfToken(),
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ read: !currentlyRead })
          });
        } catch (err) {
          console.error('Failed to persist notification state', err);
        }

        // update unread badge
        const remaining = Array.from(listEl.querySelectorAll('article')).filter(a => a.querySelector('.notif-toggle').getAttribute('aria-pressed') === 'false').length;
        if (remaining > 0) {
          unreadBadge.textContent = remaining;
          unreadBadge.classList.remove('hidden');
        } else {
          unreadBadge.classList.add('hidden');
        }
      });
    });
  }

  function getCsrfToken() {
    const cookie = document.cookie.split(';').map(c => c.trim()).find(c => c.startsWith('csrftoken='));
    return cookie ? cookie.split('=')[1] : '';
  }

  // Mark all as read
  markAllBtn.addEventListener('click', async function () {
    // optimistic UI: mark all locally
    listEl.querySelectorAll('article').forEach(article => {
      const btn = article.querySelector('.notif-toggle');
      const icon = article.querySelector('.notif-icon');
      btn.setAttribute('aria-pressed', 'true');
      icon.setAttribute('stroke', '#9CA3AF');
      icon.setAttribute('fill', 'none');
      article.classList.remove('bg-gradient-to-r','from-white','to-[#FFF7F5]');
      article.classList.add('bg-white');
    });
    unreadBadge.classList.add('hidden');

    // send request to backend
    try {
      await fetch("{% url 'Homepage:mark_all_notifications_read' %}", {
        method: 'POST',
        headers: { 'X-CSRFToken': getCsrfToken() }
      });
    } catch (err) {
      console.error('Failed to mark all read', err);
    }
  });

  // fetch notifications
  fetch(jsonUrl)
    .then(res => {
      if (!res.ok) throw new Error(res.statusText);
      return res.json();
    })
    .then(data => {
      renderList(data);
    })
    .catch(err => {
      console.error('Error fetching notifications:', err);
      loadingEl && (loadingEl.textContent = 'Failed to load notifications.');
    });
});
</script>
{% endblock scripts %}
